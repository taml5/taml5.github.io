---
import { getCollection } from "astro:content";
import type { CollectionEntry } from "astro:content";

import Layout from '../../layouts/BaseLayout.astro';
import Header from '../../components/Header.astro';
import Question from "../../components/leetcode/Question.astro";
import Review from "../../components/leetcode/Review.astro";

const categories = [
    "arrays",
    "dp",
    "graphs",
    "heaps",
    "intervals",
    "linked-lists",
    "review",
    "matrices",
    "strings",
    "trees",
];
const questionsByCategory: Record<string, CollectionEntry<"leetcode">[]> = {};

for (const category of categories) {
    questionsByCategory[category] = (await getCollection(
        'leetcode', ({ data }) => data.category === category
    )).sort((a, b) => a.data.order - b.data.order);
}   
---

<Layout>
    <Header />
    <p>This is where I post my notes for Leetcode problems I have solved. I try to focus more on the theoretical aspects and patterns rather than the cleanest or the most optimal solutionâ€”this is meant to build an intuition for approaching similar problems and spotting the underlying patterns and concepts. As such, I try to put more emphasis on where the solution comes from, and why it is correct in a somewhat more rigorous manner (although there might not be proofs of its optimality). Hopefully they will also be of some use to others.
    </p>
    <h1>Arrays</h1>
    <ul>
        {
            questionsByCategory['arrays'].map((problem) => (
                <Question 
                    number={problem.data.number} 
                    title={problem.data.title} 
                    difficulty={problem.data.difficulty} 
                    href={`/leetcode/${problem.slug}`} 
                />
            ))
        }
    </ul>
    <h1>Dynamic Programming</h1>
    <ul>
        {
            questionsByCategory['dp'].map((problem) => (
                <Question 
                    number={problem.data.number} 
                    title={problem.data.title} 
                    difficulty={problem.data.difficulty} 
                    href={`/leetcode/${problem.slug}`} 
                />
            ))
        }
    </ul>
    <h1>Heaps</h1>
    <ul>
        {
            questionsByCategory['heaps'].map((problem) => (
                <Question 
                    number={problem.data.number} 
                    title={problem.data.title} 
                    difficulty={problem.data.difficulty} 
                    href={`/leetcode/${problem.slug}`} 
                />
            ))
        }
    </ul>
    <h1>Trees</h1>
    <ul>
        {
            questionsByCategory['trees'].map((problem) => (
                <Question 
                    number={problem.data.number} 
                    title={problem.data.title} 
                    difficulty={problem.data.difficulty} 
                    href={`/leetcode/${problem.slug}`} 
                />
            ))
        }
    </ul>
    <h1>Review</h1>
    <p>
        These are brief study notes for important data structures/algorithm concepts that are foundational in Leetcode problems, to be used as a reference for the leetcode solutions above.
    </p>
    <ul>
        {
            questionsByCategory['review'].map((problem) => (
                <Review 
                    title={problem.data.title} 
                    href={`/leetcode/${problem.slug}`}
                />
            ))
        }
    </ul>
</Layout>

<style>
    body {
        margin-block-end: 4rem;
    }
</style>
