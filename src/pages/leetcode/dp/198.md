---
layout: ../../../layouts/Leetcode.astro
---

# 198. House Robber

> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.
> 
> Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.
> 
> **Constraints:**
>- `1 <= nums.length <= 100`
>- `0 <= nums[i] <= 400`

Let $h_0, \dotsc, h_n$ represent the money in houses $0, \dotsc, n$, and let $OPT(i)$ represent the maximum amount of money that can be robbed from houses $i, \dotsc, n$. At the next house $h_i$, the robber has two choices:
- Rob $h_i$. If he does so, he cannot rob $h_{i+1}$ without alerting the police, so the most amount he can still make is $h_i + OPT(i + 2)$.
- Don't rob $h_i$. In this case, he can rob $h_{i+1}$ as well as the rest of the remaining houses, so the most amount he can still make is $OPT(i + 1)$.
Of course, if $i > n$ there there is no house to rob, so he makes $0. Then 
  $$
  OPT(i) = \begin{cases}
  0 & i > n \\
  \max(h_i + OPT(i + 2), OPT(i + 1)) & otherwise
  \end{cases}
  $$
## Top-Down
```python
def rob(self, nums: List[int]) -> int:
	def rob_subset(i: int) -> int:
		"""Return the optimal money that we can rob from houses 
		in nums[i:] without alerting the police.
		"""
		if i >= len(nums):
			# if there are no houses to rob, we can't make any money!
			return 0
		else:
			# either rob the first house and skip the next one, 
			# or skip the first house and rob the rest
			if i + 1 not in solutions:
				solutions[i + 1] = rob_subset(i + 1)
			if i + 2 not in solutions:
				solutions[i + 2] = rob_subset(i + 2)
			
			return max(nums[i] + solutions[i + 2], solutions[i + 1])
	
	solutions = {}
	return rob_subset(0)
```
## Time Complexity
$\mathcal{O}(n)$
## Space Complexity
$\mathcal{O}(n)$
# Bottom-up