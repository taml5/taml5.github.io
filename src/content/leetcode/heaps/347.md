---
title: Top K Frequent Elements
category: heaps
number: 347
difficulty: Medium
order: 0
---

# 347. Top K Frequent Elements

```python
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
	import heapq
	
	count = {}
	for num in nums:
		if num not in count:
			count[num] = 1
		else:
			count[num] += 1
	
	heap = [(count[key], key) for key in count]
	heapq.heapify_max(heap)
	
	ans = []
	for i in range(0, k):
		ans.append(heapq.heappop_max(heap)[1])
	
	return ans
```

## Time Complexity
Heapify takes $\mathcal{O}(n)$ time, and so does building `count`. Each iteration of the loop takes $\mathcal{O}(\log n)$ time due to the heap pop operation. There are $k$ iterations, but notice that $k$ is in $\mathcal{O}(n)$. Thus the loop takes $\mathcal{O}(n \log n )$ run time. Since that dominates, the total algorithm has $\mathcal{O}(n \log n)$ time complexity.
## Space Complexity
The heap takes $\mathcal{O}(n)$ space, since in the worst case it stores $n$ different elements. All other variables take constant space, so the total space complexity is in $\mathcal{O}(n)$.
# Bucket Sort
This is the optimal solution with $\mathcal{O}(n)$ time, but I haven't found the solution yet. Keep posted for updates.